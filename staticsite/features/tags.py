from __future__ import annotations
from typing import List, Dict, Iterable
from staticsite.page import Page
from staticsite.render import RenderedString
from staticsite.feature import Feature
from staticsite.file import File, Dir
import functools
import os
import logging

log = logging.getLogger()


class TaxonomyFeature(Feature):
    """
    Tag pages using one or more taxonomies.

    See doc/taxonomies.md for details.
    """
    RUN_AFTER = ["contents_loaded"]
    RUN_BEFORE = ["autogenerated_pages"]

    def __init__(self, *args, **kw):
        super().__init__(*args, **kw)
        # All TaxonomyPages found
        self.taxonomies: Dict[str, TaxonomyPage] = {}

        self.j2_globals["taxonomies"] = self.jinja2_taxonomies
        self.j2_globals["taxonomy"] = self.jinja2_taxonomy

    def load_dir(self, sitedir: Dir) -> List[Page]:
        taken = []
        pages = []
        for fname, src in sitedir.files.items():
            if not fname.endswith(".taxonomy"):
                continue

            if os.path.basename(src.relpath)[:-9] not in self.site.settings.TAXONOMIES:
                log.warn("%s: ignoring taxonomy not listed in TAXONOMIES settings", src.relpath)
                continue

            page = TaxonomyPage(self.site, src, meta=sitedir.meta_file(fname))
            if not page.is_valid():
                continue
            self.taxonomies[page.name] = page
            taken.append(fname)
            pages.append(page)

        for fname in taken:
            del sitedir.files[fname]

        return pages

    def build_test_page(self, name: str, **kw) -> Page:
        page = TestTaxonomyPage(
                self.site,
                File(relpath=name + ".taxonomy", root="/", abspath="/" + name + ".taxonomy"),
                meta=kw)
        self.taxonomies[page.name] = page
        return page

    def jinja2_taxonomies(self) -> Iterable["TaxonomyPage"]:
        return self.taxonomies.values()

    def jinja2_taxonomy(self, name) -> "TaxonomyPage":
        return self.taxonomies.get(name)

    def finalize(self):
        # Call finalize on all taxonomy pages, to populate them by scanning
        # site pages
        for taxonomy in self.taxonomies.values():
            taxonomy.finalize()

        # Warn of taxonomies configured in settings.TAXONOMIES but not mounted
        # with a <name>.taxonomy
        for name in self.site.settings.TAXONOMIES:
            if name not in self.taxonomies:
                log.warn("Taxonomy %s defined in settings, but no %s.taxonomy file found in site contents: ignoring it",
                         name, name)


class TaxonomyPage(Page):
    """
    Root page for one taxonomy defined in the site
    """
    TYPE = "taxonomy"
    RENDER_PREFERRED_ORDER = 2

    def __init__(self, site, src, meta=None):
        linkpath = os.path.splitext(src.relpath)[0]

        super().__init__(
            site=site,
            src=src,
            src_linkpath=linkpath,
            dst_relpath=os.path.join(linkpath, "index.html"),
            dst_link=os.path.join(site.settings.SITE_ROOT, linkpath),
            meta=meta)
        self.meta.setdefault("template", "tags.html")

        # Taxonomy name (e.g. "tags")
        self.name = os.path.basename(linkpath)

        # Map all possible values for this taxonomy to the pages that reference
        # them
        self.categories: Dict[str, CategoryPage] = {}

        # Read taxonomy information
        self._read_taxonomy_description()

        # Metadata for category pages
        self.category_meta = self.meta.get("category", {})
        self.category_meta.setdefault("template", "tag.html")

        # Metadata for archive pages
        self.archive_meta = self.meta.get("archive", {})
        self.archive_meta.setdefault("template", "tag-archive.html")

        # Template used to render this taxonomy
        self.template_tags = self.site.theme.jinja2.get_template(self.meta.get("template_tags", "tags.html"))

        # Template used to render each single category index
        self.template_tag = self.site.theme.jinja2.get_template(self.meta.get("template_tag", "tag.html"))

        # Template used to render the archive view of each single category index
        self.template_tag_archive = self.site.theme.jinja2.get_template(
                self.meta.get("template_archive", "tag-archive.html"))

    def to_dict(self):
        from staticsite.utils import dump_meta
        res = super().to_dict()
        res["name"] = self.name
        res["categories"] = dump_meta(self.categories)
        res["category_meta"] = dump_meta(self.category_meta)
        res["archive_meta"] = dump_meta(self.archive_meta)
        return res

    def _read_taxonomy_description(self):
        """
        Parse the taxonomy file to read its description
        """
        from staticsite.utils import parse_front_matter
        with open(self.src.abspath, "rt") as fd:
            lines = [x.rstrip() for x in fd]
        try:
            style, meta = parse_front_matter(lines)
            self.meta.update(**meta)
        except Exception:
            log.exception("%s: cannot parse taxonomy information", self.src.relpath)

    def __getitem__(self, name):
        return self.categories[name]

    def finalize(self):
        # Scan all pages for taxonomies.
        # We cannot do it by hooking into page loads, because at that point
        # .taxonomy files are not guaranteed to have been loaded
        for page in list(self.site.pages.values()):
            categories = page.meta.get(self.name)
            if categories is None:
                continue
            self.add_page(page, categories)

        # Finalize categories
        self.categories = {k: v for k, v in sorted(self.categories.items())}
        for category in self.categories.values():
            category.finalize()

    def add_page(self, page, categories):
        """
        Add a page to this taxonomy.

        :arg categories: a sequence of categories that the page declares for
                         this taxonomy
        """
        if isinstance(categories, str):
            categories = (categories,)
        category_pages = []
        for v in categories:
            category_page = self.categories.get(v, None)
            if category_page is None:
                category_page = CategoryPage(self, v, meta=self.category_meta)
                if not category_page.is_valid():
                    log.error("%s: unexpectedly reported page not valid, but we have to add it anyway", category_page)

                archive_page = CategoryArchivePage(category_page, meta=self.archive_meta)
                if not archive_page.is_valid():
                    log.error("%s: unexpectedly reported page not valid, but we have to add it anyway", category_page)

                self.categories[v] = category_page
                category_page.archive = archive_page

                self.site.pages[category_page.src_linkpath] = category_page
                self.site.pages[category_page.archive.src_linkpath] = archive_page
            category_pages.append(category_page)
            category_page.add_page(page)

        # Replace tag names in page.meta with CategoryPage pages
        category_pages.sort(key=lambda p: p.name)
        page.meta[self.name] = category_pages

    def render(self):
        res = {}

        if self.template_tags is not None:
            body = self.render_template(self.template_tags)
            res[self.dst_relpath] = RenderedString(body)

        return res


@functools.total_ordering
class CategoryPage(Page):
    """
    Index page showing all the pages tagged with a given taxonomy item
    """
    TYPE = "category"
    RENDER_PREFERRED_ORDER = 2

    def __init__(self, taxonomy, name, meta=None):
        relpath = os.path.join(taxonomy.src_linkpath, name)
        super().__init__(
            site=taxonomy.site,
            src=File(relpath=relpath),
            src_linkpath=relpath,
            dst_relpath=os.path.join(relpath, "index.html"),
            dst_link=os.path.join(taxonomy.site.settings.SITE_ROOT, relpath),
            meta=meta)
        # Category name
        self.name = name
        # Taxonomy we belong to
        self.taxonomy: TaxonomyPage = taxonomy
        # Pages that have this category
        self.pages: List[Page] = []
        # Index of each page in the category sequence
        self.page_index: Dict[Page, int] = {}

        self.meta.setdefault("template_title", "{{page.name}}")
        self.meta.setdefault("date", taxonomy.meta["date"])

        # Archive page
        self.archive = None

    def to_dict(self):
        from staticsite.utils import dump_meta
        res = super().to_dict()
        res["name"] = self.name
        res["taxonomy"] = dump_meta(self.taxonomy)
        res["pages"] = dump_meta(self.pages)
        res["archive"] = dump_meta(self.archive)
        return res

    def __lt__(self, o):
        o_taxonomy = getattr(o, "taxonomy", None)
        if o_taxonomy is None:
            return NotImplemented

        o_name = getattr(o, "name", None)
        if o_name is None:
            return NotImplemented

        return (self.taxonomy.name, self.name) < (o_taxonomy.name, o_name)

    def __eq__(self, o):
        o_taxonomy = getattr(o, "taxonomy", None)
        if o_taxonomy is None:
            return NotImplemented

        o_name = getattr(o, "name", None)
        if o_name is None:
            return NotImplemented

        return (self.taxonomy.name, self.name) == (o_taxonomy.name, o_name)

    def add_page(self, page):
        """
        Add a page to this category.
        """
        # Our date is the maximum of all pages
        page_date = page.meta["date"]
        if page_date > self.meta["date"]:
            self.meta["date"] = page_date

        self.pages.append(page)

    def finalize(self):
        self.pages.sort(key=lambda x: x.meta["date"])
        # Store page indices
        self.page_index = {page.src_linkpath: idx for idx, page in enumerate(self.pages)}
        self.archive.finalize()

    def sequence(self, page):
        idx = self.page_index.get(page.src_linkpath)
        if idx is None:
            return None
        return {
            # Array with all the pages in the series
            "pages": self.pages,
            # Assign series_prev and series_next metadata elements to pages
            "index": idx + 1,
            "length": len(self.pages),
            "first": self.pages[0],
            "last": self.pages[-1],
            "prev": self.pages[idx - 1] if idx > 0 else None,
            "next": self.pages[idx + 1] if idx < len(self.pages) - 1 else None,
            "title": self.pages[0].meta.get("title", self.name),
        }

    def render(self):
        return {
            self.dst_relpath: RenderedString(self.render_template(self.taxonomy.template_tag)),
        }


class CategoryArchivePage(Page):
    """
    Index page showing the archive page for a CategoryPage
    """
    TYPE = "category_archive"
    RENDER_PREFERRED_ORDER = 2

    def __init__(self, category_page, meta=None):
        relpath = os.path.join(category_page.src_linkpath, "archive")
        super().__init__(
            site=category_page.site,
            src=File(relpath=relpath),
            src_linkpath=relpath,
            dst_relpath=os.path.join(relpath, "index.html"),
            dst_link=os.path.join(category_page.site.settings.SITE_ROOT, relpath),
            meta=meta)

        # Category name
        self.name = category_page.name

        # Taxonomy we belong to
        self.taxonomy: TaxonomyPage = category_page.taxonomy

        # Category we belong to
        self.category: CategoryPage = category_page

        self.meta.setdefault("template_title", "{{page.name}} archive")
        self.meta.setdefault("date", category_page.meta["date"])

    def to_dict(self):
        from staticsite.utils import dump_meta
        res = super().to_dict()
        res["name"] = self.name
        res["taxonomy"] = dump_meta(self.taxonomy)
        res["category"] = dump_meta(self.category)
        return res

    def finalize(self):
        self.meta["date"] = self.category.meta["date"]
        self.pages = self.category.pages

    def render(self):
        return {
            self.dst_relpath: RenderedString(self.render_template(self.taxonomy.template_tag_archive)),
        }


class TestTaxonomyPage(TaxonomyPage):
    def _read_taxonomy_description(self):
        pass


FEATURES = {
    "tags": TaxonomyFeature,
}
