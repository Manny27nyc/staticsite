from __future__ import annotations
from typing import Dict, Any, Optional
from staticsite.feature import Feature
from staticsite.theme import PageFilter
from staticsite.render import RenderedString
from staticsite import Page, Site, File
import os
import logging

log = logging.getLogger("syndication")


class SyndicationFeature(Feature):
    """
    Build syndication feeds for groups of pages.

    One page is used to define the syndication, using "syndication_*" tags.

    Use a data page without type to define a contentless syndication page
    """
    RUN_AFTER = ["autogenerated_pages", "pages"]

    def __init__(self, *args, **kw):
        super().__init__(*args, **kw)
        self.site.tracked_metadata.add("syndication")
        self.site.features["rst"].yaml_tags.add("syndication")
        self.syndications = []

    def finalize(self):
        # Build syndications from pages with a 'syndication' metadata
        for page in self.site.pages_by_metadata["syndication"]:
            syndication_meta = page.meta.get("syndication")
            if syndication_meta is None:
                continue

            # Index page for the syndication
            syndication_meta["index"] = page

            # Pages in the syndication
            select = syndication_meta.get("filter")
            if select:
                f = PageFilter(self.site, **select)
                pages = f.filter(self.site.pages.values())
            else:
                pages = page.meta.get("pages", [])
            syndication_meta["pages"] = pages

            # RSS feed
            rss_page = RSSPage(self.site, syndication_meta)
            if rss_page.is_valid():
                syndication_meta["rss_page"] = rss_page
                self.site.add_page(rss_page)
                log.debug("%s: adding syndication page for %s", rss_page, page)

            # Atom feed
            atom_page = AtomPage(self.site, syndication_meta)
            if atom_page.is_valid():
                syndication_meta["atom_page"] = atom_page
                self.site.add_page(atom_page)
                log.debug("%s: adding syndication page for %s", rss_page, page)

            # Add a link to the syndication to the pages listed in add_to
            add_to = syndication_meta.get("add_to")
            if add_to:
                f = PageFilter(self.site, **add_to)
                for dest in f.filter(self.site.pages.values()):
                    old = dest.meta.get("syndication")
                    if old is not None:
                        log.warn("%s: attempted to add meta.syndication from %s, but it already has it from %s",
                                 dest, page, old["index"])
                    dest.meta["syndication"] = syndication_meta


class SyndicationPage(Page):
    """
    Base class for syndication pages
    """
    RENDER_PREFERRED_ORDER = 2

    def __init__(self, site: Site, meta: Dict[str, Any]):
        relpath = os.path.join(meta["index"].src_linkpath, f"index.{self.TYPE}")

        super().__init__(
            site=site,
            src=File(relpath=relpath),
            src_linkpath=relpath,
            dst_relpath=relpath,
            dst_link=os.path.join(site.settings.SITE_ROOT, relpath),
            meta=meta)
        self.meta.setdefault("template", self.TEMPLATE)
        if self.meta["pages"]:
            self.meta["date"] = max(p.meta["date"] for p in self.meta["pages"])
        else:
            self.meta["date"] = self.site.generation_time

    def render(self):
        body = self.render_template(self.page_template)
        return {
            self.dst_relpath: RenderedString(body)
        }


class RSSPage(SyndicationPage):
    """
    A RSS syndication page
    """
    TYPE = "rss"
    TEMPLATE = "syndication.rss"


class AtomPage(SyndicationPage):
    """
    An Atom syndication page
    """
    TYPE = "atom"
    TEMPLATE = "syndication.atom"


FEATURES = {
    "syndication": SyndicationFeature,
}
